
# ES6 新增的变量命名
## let 命令
ES6 语法中增加了`let`命令，用于变量的声明。用法类似于var，但这个声明的变量，只在声明所在的代码块有效
```js
{
    let a = 'hello world';
    console.log(a); // 输出 -> hello world
}
console.log(a)// error -> ReferenceError：a is not defined

```
在`for`循环里 `var`和`let`的比较
```js
var a = [];
for(var i = 0 ; i < 10 ; i++){
    a[i] = () => console.log(i);
}
a[5]();// 输出 -> 10
for(let k = 0;k < 10 ; k++){
    a[k] = () => console.log(k);
}
a[5](); // 输出 -> 5
```
`var` 变量声明是在全局范围内有效，所有在全局里只有一个变量`i`每循环一次，变量`i`的值都会发生改变而在循环里赋值给数据的箭头函数中的`i`是指向全局变量的`i`，所有在数组成员中的`i` 都是指向同一个全局`i`,从而在输出的时候是打印的是最后一次循环的`i`的值

变量`k`是通过`let`声明的，当前的`k`只在当前的循环有效。所以每次循环`k`其实是一个新的变量，于是输出的是`5`。
那么问题来了，如果每次都是从新定义那么`k`的值是怎么保留上一次循环的值而不是从`0`开始呢？
这是因为：JavaScript引擎内部会记录上一轮的值，初始化`k`的时候,就将上一轮的值经过计算后初始化给`k`

tip: for 循环也有两个作用域的区域，
     第一个是在设置循环变量部分，可以称为父作用域
     第二个是在循环体的内部，可以称为子作用域
```js
for(let k=0 ; k < 3 ; k++ ){
    // 输出 -> hello xiaou * 3
    let k = "hello xiaou";
    console.log(k);
}
```
就如上段代码，并不会报出`Error`
### 使用 `let` 避免'变量提升'
使用 `var` 关键字声明的变量如果在`var`之前使用变量不会报出Error，而变量的值是`undefined`,这种方式也称为js的预解析
在ES6中用`let`关键字声明的变量必须要在声明后再使用负责会报出`ReferenceError`的错误
## 短暂性死区
只要块级作用域存在`let`命令，它所声明的变量就绑定了这个区域,不在受到外界的影响
```js
var a = 123;
if (true) {
    console.log(a)// 不会输出123
    let a = "456"
    console.log(a) // 输出 -> 456
}
```
以上代码是存在全局变量`tmp`，但块级作用域内有用`let`又声明了一个局部变量`tmp`导致后者绑定这个块级作用域，所以在同一个块级作用域`let`声明变量前，对tmp赋值会发生异常

>ES6 指出在块级作用域存在`let`或者`const`命令,则这个区块对这些命令声明的变量，从一开始就形成封闭作用域。只要在声明之前，该变量都不是可用的。
在语法上称为`temporal dead zone` 暂时性死区 简称 `TDZ`

正因为 `TDZ` 暂时性死区的出现 导致了 `typeof` 不再是一个安全操作
```js
typeof x; // 会报出错误
let x;
```
只要在`let`和`const`声明的变量在当前的块级作用域之前都是这个变量的死区，这要在这块区域使用可能报出错误
```js
typeof a // undefined
```
如果没有定义 使用 `typeof ` 那么还是 `undefined`

隐蔽死区
```js
// 1. 在形参中
function a(x = y, y =2){
    return [x , y];
}
// 2. x还未定义
let x = x;
```
## 其他
let 允许在相同作用域内重复声明一个变量
# 作用域
在本质上 块级作用域是一个语句，将多个操作封装到一起，并没有返回值
```js
{
  let t = "hello world";
  console.log(t);
}
```
## const 命令
const 用法基本上在和let一样但是const是定义常量的
### 对象常量
对象常量是值得注意，因为对象常量是指向一个地址，而可以进行下面这样的操作
```js
// 对属性的操作
const a = [];
a.push("1");// √
a.pop();// √
```
不可以操作
```js
const a = [];
a = ['hello'] // ×
```
